{"ast":null,"code":"/** @license React v16.6.1\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    /* eslint-disable no-var */\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var IdlePriority = 4;\n\n    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n    var maxSigned31BitInt = 1073741823;\n\n    // Times out immediately\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    // Eventually times out\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    // Never times out\n    var IDLE_PRIORITY = maxSigned31BitInt;\n\n    // Callbacks are stored as a circular, doubly linked list.\n    var firstCallbackNode = null;\n    var currentDidTimeout = false;\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1;\n\n    // This is set when a callback is being executed, to prevent re-entrancy.\n    var isExecutingCallback = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      }\n      // Schedule the host callback using the earliest expiration in the list.\n      var expirationTime = firstCallbackNode.expirationTime;\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n      _requestHostCallback(flushWork, expirationTime);\n    }\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode;\n\n      // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = firstCallbackNode.next;\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n      flushedNode.next = flushedNode.previous = null;\n\n      // Now it's safe to call the callback.\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n      try {\n        continuationCallback = callback();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      }\n\n      // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n      if (typeof continuationCallback === 'function') {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        };\n\n        // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n            node = node.next;\n          } while (node !== firstCallbackNode);\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n    function flushImmediateWork() {\n      if (\n      // Confirm we've exited the outer most event handler\n      currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n        isExecutingCallback = true;\n        try {\n          do {\n            flushFirstCallback();\n          } while (\n          // Keep flushing until there are no more immediate callbacks\n          firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n        } finally {\n          isExecutingCallback = false;\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n    function flushWork(didTimeout) {\n      isExecutingCallback = true;\n      var previousDidTimeout = currentDidTimeout;\n      currentDidTimeout = didTimeout;\n      try {\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (firstCallbackNode !== null) {\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n              continue;\n            }\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && !shouldYieldToHost());\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n        currentDidTimeout = previousDidTimeout;\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        }\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime;\n\n        // Before exiting, flush all the immediate work that was scheduled.\n        flushImmediateWork();\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n      var expirationTime;\n      if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n      var newNode = {\n        callback: callback,\n        priorityLevel: currentPriorityLevel,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n\n      // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled();\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n        do {\n          if (node.expirationTime > expirationTime) {\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n          node = node.next;\n        } while (node !== firstCallbackNode);\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n      return newNode;\n    }\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      callbackNode.next = callbackNode.previous = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    function unstable_shouldYield() {\n      return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n    }\n\n    // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n    // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n    var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n    var _requestHostCallback;\n    var cancelHostCallback;\n    var shouldYieldToHost;\n    if (typeof window !== 'undefined' && window._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var impl = window._schedMock;\n      _requestHostCallback = impl[0];\n      cancelHostCallback = impl[1];\n      shouldYieldToHost = impl[2];\n    } else if (\n    // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' ||\n    // \"addEventListener\" might not be available on the window object\n    // if this is a mocked \"window\" object. So we need to validate that too.\n    typeof window.addEventListener !== 'function') {\n      var _callback = null;\n      var _currentTime = -1;\n      var _flushCallback = function _flushCallback(didTimeout, ms) {\n        if (_callback !== null) {\n          var cb = _callback;\n          _callback = null;\n          try {\n            _currentTime = ms;\n            cb(didTimeout);\n          } finally {\n            _currentTime = -1;\n          }\n        }\n      };\n      _requestHostCallback = function requestHostCallback(cb, ms) {\n        if (_currentTime !== -1) {\n          // Protect against re-entrancy.\n          setTimeout(_requestHostCallback, 0, cb, ms);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, ms, true, ms);\n          setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);\n        }\n      };\n      cancelHostCallback = function cancelHostCallback() {\n        _callback = null;\n      };\n      shouldYieldToHost = function shouldYieldToHost() {\n        return false;\n      };\n      exports.unstable_now = function () {\n        return _currentTime === -1 ? 0 : _currentTime;\n      };\n    } else {\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n      var scheduledHostCallback = null;\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0;\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      shouldYieldToHost = function shouldYieldToHost() {\n        return frameDeadline <= exports.unstable_now();\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n      var idleTick = function idleTick(event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n        isMessageEventScheduled = false;\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            }\n            // Exit without invoking the callback.\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      };\n      // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n      window.addEventListener('message', idleTick, false);\n      var animationTick = function animationTick(rafTime) {\n        if (scheduledHostCallback !== null) {\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n      _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        timeoutTime = absoluteTimeout;\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          window.postMessage(messageKey, '*');\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n      cancelHostCallback = function cancelHostCallback() {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","ImmediatePriority","UserBlockingPriority","NormalPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstCallbackNode","currentDidTimeout","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","ensureHostCallbackIsScheduled","expirationTime","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","didTimeout","previousDidTimeout","currentTime","unstable_now","shouldYieldToHost","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","unstable_shouldYield","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","window","_schedMock","impl","addEventListener","_callback","_currentTime","_flushCallback","ms","cb","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","messageKey","Math","random","toString","slice","idleTick","event","source","data","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority"],"sources":["/Users/isabellapearce/Desktop/09-todo-react-group-bella-yina/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v16.6.1\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar IdlePriority = 4;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentDidTimeout = false;\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  isExecutingCallback = true;\n  var previousDidTimeout = currentDidTimeout;\n  currentDidTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    currentDidTimeout = previousDidTimeout;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar shouldYieldToHost;\n\nif (typeof window !== 'undefined' && window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestHostCallback = impl[0];\n  cancelHostCallback = impl[1];\n  shouldYieldToHost = impl[2];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// \"addEventListener\" might not be available on the window object\n// if this is a mocked \"window\" object. So we need to validate that too.\ntypeof window.addEventListener !== 'function') {\n  var _callback = null;\n  var _currentTime = -1;\n  var _flushCallback = function (didTimeout, ms) {\n    if (_callback !== null) {\n      var cb = _callback;\n      _callback = null;\n      try {\n        _currentTime = ms;\n        cb(didTimeout);\n      } finally {\n        _currentTime = -1;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_currentTime !== -1) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb, ms);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, ms, true, ms);\n      setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n  exports.unstable_now = function () {\n    return _currentTime === -1 ? 0 : _currentTime;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  shouldYieldToHost = function () {\n    return frameDeadline <= exports.unstable_now();\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}